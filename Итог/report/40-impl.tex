\chapter{Технологический раздел}
\label{cha:impl}

В данном разделе будет обоснован выбор языка программирования и среды разработки, представлены реализации алгоритмов и рассмотрен интерфейс программы.

\section{Требования к программному обеспечению}

Программа должна предоставлять доступ к функционалу:

\begin{itemize}
	\item возможность выбора материала покрытия пола и стен из предложенных вариантов (дерево, бумага(обои), керамика(плитка));
	\item изменение скорости движения частиц;
	\item изменение количества частиц инфекции;
	\item включение и выключение работы модели распространения частиц;
	\item вращение, перемещение и масштабирование модели.
\end{itemize}

\section{Средства реализации}

В качестве языка программирования для реализации курсовой работы использовался язык программирования C++ \cite{cplusplus}, т.к. он содержит возможности для работы с массивами и нативными потоками. В качестве среды разработки использовалась Visual Studio Code \cite{vscode}. Для замеров времени  использовалась функция time() из заголовочного файла time.h \cite{cplusplus}. Для отображения результирующих данных в виде графиков была использована библиотека языка Python matplotlib \cite{matplotlib}.

\section{Реализация алгоритмов}

В листингах \ref{code:getNormal} -- \ref{code:brown} представлена реализация алгоритмов моделирования броуновского движения и отрисовки сцены.

\begin{lstlisting}[label=code:getNormal,caption=Реализация вспомогательной функции вычисления распределенной нормально случайной величины]
float BrownianMotion::getNormalRandom()
{
	static default_random_engine e;
	static uniform_real_distribution<> dis(-0.15, 0.15);
	return dis(e);
}
\end{lstlisting}

\newpage

\begin{lstlisting}[label=code:brown,caption=Реализация расчета изменения координат центров частиц (броуновское движение)]
void BrownianMotion::setVirusCountAndResetAllIfNeeded(int newVirusCount)
{
	if (virusCount == newVirusCount)
	{
		return;
	}
	virusCount = newVirusCount;
	float sigma = 0.2;
	data = std::vector<std::vector<Vector3f>>(virusCount, std::vector<Vector3f>(SIZE + 1));
	for (int k = 0; k < virusCount; k++)
	{
		data.at(k).at(0) = Vector3f(0.0, 0.0, 0.0);
		data.at(k).at(SIZE) = Vector3f(sigma * getNormalRandom(), sigma * getNormalRandom(), sigma * getNormalRandom());
		for (int j = 1; j <= POWER; j++)
		{
			for (int i = 1; i <= pow(2, (j - 1)); i++)
			{
				int ind = (2 * i - 1) * pow(2, POWER - j);
				int old1 = (i - 1) * pow(2, POWER - j + 1);
				int old2 = i * pow(2, POWER - j + 1);
				data.at(k).at(ind).x = (data.at(k).at(old1).x + data.at(k).at(old2).x) / 2 + sigma * getNormalRandom() / pow(2, (j + 1) / 2);
				data.at(k).at(ind).y = (data.at(k).at(old1).y + data.at(k).at(old2).y) / 2 + sigma * getNormalRandom() / pow(2, (j + 1) / 2);
				data.at(k).at(ind).z = (data.at(k).at(old1).z + data.at(k).at(old2).z) / 2 + sigma * getNormalRandom() / pow(2, (j + 1) / 2);
			}
		}
	}
}
\end{lstlisting}

\section*{Вывод}
В данном разделе были перечислены требования к ПО, средства разработки, с помощью которых были реализованы последовательный и параллельный алгоритмы сортировки массивов, приведены листинги реализаций каждого из алгоритмов, а также тесты к ним.


