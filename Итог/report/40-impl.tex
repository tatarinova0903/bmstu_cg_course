\chapter{Технологический раздел}
\label{cha:impl}

В данном разделе будет обоснован выбор языка программирования и среды разработки, представлены реализации алгоритмов и рассмотрен интерфейс программы.

\section{Требования к программному обеспечению}

Программа должна предоставлять доступ к функционалу:

\begin{itemize}
	\item возможность выбора материала покрытия пола и стен из предложенных вариантов (дерево, бумага(обои), керамика(плитка));
	\item изменение скорости движения частиц;
	\item изменение количества частиц инфекции;
	\item включение и выключение работы модели распространения частиц;
	\item вращение, перемещение и масштабирование модели.
\end{itemize}

\section{Средства реализации}

В качестве языка программирования для реализации курсовой работы использовался язык программирования C++ \cite{cplusplus}, т.к. он содержит возможности для работы с массивами и нативными потоками. В качестве среды разработки использовалась Visual Studio Code \cite{vscode}. Для замеров времени  использовалась функция time() из заголовочного файла time.h \cite{cplusplus}. Для отображения результирующих данных в виде графиков была использована библиотека языка Python matplotlib \cite{matplotlib}.

\section{Реализация алгоритмов}

В листингах \ref{code:comp_and_swap} -- \ref{code:parallel_bitonic} представлена реализация последовательного и параллельного алгоритмов битонной сортировки.

\begin{lstlisting}[label=code:comp_and_swap,caption=Реализация вспомогательной функции обмена значениями элементов в массиве]
void comp_and_swap(vector<int>& arr, unsigned long i, unsigned long j, 
int dir)
{
	if (dir == (arr[i] > arr[j]))
	{
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
}
\end{lstlisting}


\begin{lstlisting}[label=code:bitonic,caption=Реализация последовательного алгоритма битонной сортировки]
def compare_swap(arr, i, j, d):
	if (d == 1 and arr[i] > arr[j]) or (d == 0 and arr[i] < arr[j]):
		arr[i], arr[j] = arr[j], arr[i]

def merge(arr, low, size, d):
	if size > 1:
		high = size // 2
		for i in range(low, low + high):
			compare_swap(arr, i, i + high, d)
		merge(arr, low, high, d)
		merge(arr, low + high, high, d)

def bitonic_sort_rec(arr, low, size, d):
	if size > 1:
		high = int(size / 2)
		bitonic_sort_rec(arr, low, high, 1)
		bitonic_sort_rec(arr, low + high, high, 0)
		merge(arr, low, size, d)

def bitonic_sort(arr):
	bitonic_sort_rec(arr, 0, len(arr), 1)
	return arr
\end{lstlisting}

\begin{lstlisting}[label=code:parallel_bitonic,caption=Реализация параллельного алгоритма битонной сортировки]
void bitonic_merge_parallel(vector<int>& arr, unsigned long low, int size, 
	unsigned long iter_count, int thread_number, int dir)
{
	for (int i = 0; i < size * iter_count; i += size)
	{
		unsigned long med = size / 2;
		unsigned long start = low + (thread_number * iter_count * size) + i;
		for (unsigned long k = start; k < start + med; k++)
		{
			comp_and_swap(arr, k, k + med, dir);
		}
	}
}

void bitonic_sort_rec(vector<int>& arr, unsigned long low, 
	unsigned long size, int dir, int threads_count)
{
	vector<thread> threads(threads_count);
	if (size > 1)
	{
		unsigned long k = size / 2;
		bitonic_sort_rec(arr, low, k, 1, threads_count);
		bitonic_sort_rec(arr, low + k, k, 0, threads_count);
		for (unsigned long j = size; j >= 2; j /= 2)
		{
			unsigned long for_count = size / j;
			unsigned long real_threads_count = min(for_count, threads_count);
			unsigned long iter_count = for_count / real_threads_count;
			for (int i = 0; i < real_threads_count; i++)
			{
				threads[i] = thread(bitonic_merge_parallel, ref(arr), low, j, iter_count, i, dir);
				threads[i].join();
			}
		}
	}
}

void parallel_bitonic_sort(vector<int>& arr, int threads_count)
{
	bitonic_sort_rec(arr, 0, arr.size(), 1, threads_count);
}
\end{lstlisting}

\section*{Вывод}
В данном разделе были перечислены требования к ПО, средства разработки, с помощью которых были реализованы последовательный и параллельный алгоритмы сортировки массивов, приведены листинги реализаций каждого из алгоритмов, а также тесты к ним.


