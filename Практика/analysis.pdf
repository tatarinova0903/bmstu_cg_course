\chapter{Аналитическая часть}

\section{Понятие броуновского движения}

\textbf{Броуновское движение} (иногда называют Брауновское движение) -- беспорядочное движение малых частиц, взвешенных в жидкости или газе, происходящее под действием молекул окружающей среды. Исследовано в 1827 г. Броуном (Браун; Brown), который наблюдал в микроскоп движение цветочной пыльцы, взвешенной в воде. 

\imgHeight{60mm}{brown_movement.png}{Броуновское движение}

Частицы размером около 1 мкм и менее совершают неупорядоченные независимые движения, описывая сложные зигзагообразные траектории. Интенсивность броуновского движения не зависит от времени, но возрастает с увеличением температуры, уменьшением вязкости и размеров частиц (независимо от их химической природы.)

Теория броуновского движения была построена независимо друг от друга Эйнштейном и Смолуховским в 1905-1906 гг. Причиной броуновского движения является тепловое движение молекул среды, проявляющееся в некомпенсированных ударах молекул о частицу, т.е. в флуктуациях давления. Эти удары приводят частицу в беспорядочное движение. Если отмечать положения частицы через равные небольшие промежутки времени, то траектория окажется сложной и запутанной.

Как показывают опытные данные, квадрат смещения частицы из начального положения в проекции на любую ось $ \langle x^2 \rangle $ за время наблюдения $\tau$, в отсутствие внешних сил определяется выражением $  \langle x^2 \rangle $ = 2D$\tau$, где коэффициент диффузии броуновской (сферической) частицы D = $\frac{\textit{k}T}{6\pi\eta\textit{a}}$, \textit{a} – радиус частицы, $\eta$ - коэффициент вязкости.

При описании броуновского движения частицы в одномерном случае можно считать, что на частицу действует сила случайная сила, среднее значение которой равно нулю $  \langle F_x \rangle $ = $\lim\limits_{t \to \infty} \{\frac{1}{t}\int_{0}^{t}F_x\mathrm{d}t\}$ = 0 и сила сопротивления $F_c$ = r$v_x$, где r - коэффициент вязкого трения броуновской частицы в жидкости.  Уравнение движения  \textit{m$a_x$} = $F_x$ - $F_c$ при подстановке выражение для силы примет вид

\begin{equation}
	m\ddot{x} + r\dot{x} = F_x
\end{equation}

Умножим это урвнение на $x$ и используем равенство  $x$$\ddot{x}$ = $\frac{\mathrm{d}(x\dot{x})}{\mathrm{d}t}$ - $\dot{x}^2$

\begin{equation}
	m\frac{\mathrm{d}(x\dot{x})}{\mathrm{d}t} - m\dot{x}^2 + rx\dot{x} = xF_x
\end{equation}

Проведем усреднение по времени 

\begin{equation}
	m\langle \frac{\mathrm{d}(x\dot{x})}{\mathrm{d}t} \rangle - m\langle \dot{x}^2 \rangle + r\langle x\dot{x} \rangle = \langle xF_x \rangle
\end{equation}

Тогда $\langle$ x$F_x$ $\rangle$ = $\lim\limits_{t \to \infty} \{\frac{1}{t}\int_{0}^{t}xF_x\mathrm{d}t\}$ = $\lim\limits_{t \to \infty} \{x\frac{1}{t}\int_{0}^{t}F_x\mathrm{d}t-\frac{1}{t}\int_{0}^{t}(\int_{0}^{t}F_x\mathrm{d}t)\dot{x}\mathrm{d}t\}$ = 0. Для одномерного движения по теореме о распределении энергии по степеням свободы $\frac{m\langle \dot{x}^2 \rangle}{2} =\frac{kT}{2} $

Заменяем $\langle$ $\frac{\mathrm{d}(x\dot{x})}{\mathrm{d}t}$ $\rangle$ = $\frac{\mathrm{d}\langle x\dot{x} \rangle}{\mathrm{d}t}$ и получаем уравнение m$\frac{\mathrm{d}\langle x\dot{x} \rangle}{\mathrm{d}t}$ + r$\langle$ x$\dot{x}$ $\rangle$ = kT, откуда

\begin{equation}
	\langle x\dot{x} \rangle = \frac{kT}{r}(1 - e^{-\frac{m}{r}t})
\end{equation}

Для установившегося движения $\langle$ \textit{x}$\dot{x}$ $\rangle$ = $\frac{kT}{r}$. Так как x$\dot{x}$ = $\frac{1}{2}$ $\frac{\mathrm{d}(x^2)}{\mathrm{d}t}$, то $\frac{\mathrm{d}\langle x^2 \rangle}{\mathrm{d}t}$ = $\frac{kT}{r}$. После интеграрирования по времени получаем $\langle$ $x^2$ $\rangle$ = 2$\frac{kT}{r}t$. Для сферической броуновской частицы, радиус которой равен \textit{a}: \textit{r} = 6$\pi$$\eta$\textit{a}, поэтому D = $\frac{\textit{k}T}{6\pi\eta\textit{a}}$.

Полученные выше формулы были экспериментально проверены в 1908 году Перреном, который измерял с помощью микроскопа перемещения броуновских частиц за одинаковые промежутки времени. Ему удалось на основании своих опытов с помощью этих формул определить постоянную Больцмана \textit{k} и вычислить значение постоянной Авогадро $N_A$, совпадающие по величине с их значениями, полученными другими методами.

\section{Моделирование броуновского движения}

\subsection{Классическое броуновское движение}

Рассмотрим случайный процесс (случайную величину) \textit{X(t)}, заданную на отрезке [0,\textit{T}].

\textit{Случайный процесс}  \textit{X(t)} называется одномерным броуновским движением (или винеровским процессом) на интервале [0,\textit{T}], если он обладает следущими свойствами:
\begin{itemize} 
\item \textit{X}(0) = 0 почти наверное и \textit{X(t)} - почти наверное непрерывная функция на [0,\textit{T}]
\item \textit{X(t)} - процесс с независимыми приращениями
\item  \textit{X(t)} -  процесс с приращениями, распределёнными нормально.
\end{itemize}

Отметим следующие свойства броуновского движения:
\begin{itemize} 
	\item \textit{X(t)} почти наверное нигде не дифференцируем 
	\item  \textit{X(t)} - марковский процесс (не обладает памятью), т.е. если известна величина \textit{X(t)}, то при $t_1$ < $t$ < $t_2$ величины \textit{X($t_1$)} и \textit{X($t_2$)} независимы.
	\item Фрактальная размерность графика \textit{X(t)} равна 1.5
	\item Приращение \textit{X(t)} обладает свойством статистического самоподобия: для любого $r$ > 0
	\begin{equation}
		X(t+ \bigtriangleup t) = \frac{1}{\sqrt{r}}(X(t+r\bigtriangleup t) - X(t))
	\end{equation}
	\item Стационарность приращений: дисперсия приращения зависит только от разности моментов времени
	\begin{equation} \label{1.6}
		D(X(t_2) - X(t_1)) = \sigma^2|t_2-t_1|
	\end{equation}
	\item Математическое ожидание приращения равно
	\begin{equation}
	E(|X(t_2) - X(t_1)|) = \sqrt{\frac{2}{\pi}}\sigma\sqrt{|t_2-t_1|}
	\end{equation}
\end{itemize}

Для моделрования броуновского движения можно воспользоваться разными алгоритмами. Рассмотрим 3 из них.

Проще всего реализовать дискретную реализацию броуновского движения, рассмотрев последовательность $x_0$ = 0, $x_{n+1} = x_n + g_n$, где $g_n$ - случайная величина, имеющая нормальное распределение (например, $N(0,1)$).

\begin{algorithmic}[1]
	\State $array[N]$
	\State $array[0]\gets 0$
	\For{i = 1,..., $N$}
	\State $array[i+1]\gets array[i] + randomNormal(0,1)$
	\EndFor
\end{algorithmic}

\subsection{Алгоритм срединных смещений}

Метод случайного срединного смещения основан на работах Н.Виннера , он более сложен, чем метод из предыдущего параграфа, однако используется для конструктивного доказательства существования броуновского движения, а также для построения фрактальной интерполяции (когда необходимо чтобы кривая проходила через заданные точки интерполяции). Метод также может быть обобщен на случай $n$-мерных броуновских движений.

Алгоритм случайного срединного смещения вычисляет значения $X(t)$ в диадических рациональных точках вида $\frac{k}{2^n}$ $\in$ [0,1]. Последовательно вычисляются значения в середине отрезка [0,1], а затем в серединах отрезков [0, $\frac{1}{2}$] и [$\frac{1}{2}, 1$] и т.д. На каждом шаге итерации должен выполнятьяс закон дисперсии для приращения (\ref{1.6}) в вычисленных точках. Параметр $\sigma$ определяет масщтаб по вертикальной оси, не влияя на фрактальную размерность графика. 

\subsubsection{Броуновское движение методом срединнго смещения (1)}
Вход: $N$, 	$\sigma$ // $N$ - число шагов алгоритма, при этом всего $2^N + 1$ точек интерполяции, $\sigma$ - параметр вертикального масштаба, коэффициент дисперсии
 
Выход: массив значений $\left\{X(\frac{k}{2^N})\right\}_{k=0}^{2^N}$ // реализация броуновского движения $X(t)$ на дискретном множестве точек вида $t_k = \frac{k}{2^N}$, k $\in$ $[0, 2^N]$

\begin{algorithmic}[1]
	\State $X(0)\gets 0$
	\State $X(1)\gets \sigma g$ // g - случайная величина, распределенная нормально с параметрами $N(0,1)$
	\State $X(\frac{1}{2})\gets$ $\frac{1}{2}$(X(0) + X(1)) +$\frac{1}{2}$$\sigma$g
	\State $X(\frac{1}{4})\gets$ $\frac{1}{2}$(X(0) + X($\frac{1}{2}$)) + $\frac{1}{2^{\frac{3}{2}}}$$\sigma$g
	\State $X(\frac{3}{4})\gets$ $\frac{1}{2}$(X($\frac{1}{2}$) + X(1)) + $\frac{1}{2^{\frac{3}{2}}}$$\sigma$g
	\Statex
	...
	\State $X(\frac{1}{2^N})\gets$ $\frac{1}{2}$ (X(0) + X($\frac{1}{2^{N - 1}}$)) + $\frac{1}{2^{(N + 1) / 2}}$$\sigma$g
	\Statex
	...
	\State $X(\frac{2^N - 1}{2^N})\gets$  $\frac{1}{2}$ (X($\frac{2^{N - 1} - 1}{2^{N - 1}}$) + X(1)) + $\frac{1}{2^{(N + 1) / 2}}$$\sigma$g
\end{algorithmic}
	
	Заметим, что точки $t_k$ можно последовательно занумеровать номерами $k$. При этом если точка имеет вид $\frac{a}{2^b}$, то ее номер $k = a2^{N-b}$. Укажем алгорит, в котором точки $t_k$ пронумерованы эфективно.
	
\subsubsection{Броуновское движение методом срединнго смещения (2)}

Вход: $N$, 	$\sigma$ // $N$ - число шагов алгоритма, при этом всего $2^N + 1$ точек интерполяции, $\sigma$ - параметр вертикального масштаба, коэффициент дисперсии

Выход: массив значений $\left\{X(\frac{k}{2^N})\right\}_{k=0}^{2^N}$ // реализация броуновского движения $X(t)$ на дискретном множестве точек вида $t_k = \frac{k}{2^N}$, k $\in$ $[0, 2^N]$

\begin{algorithmic}[1]
	\State $X(0)\gets 0$
	\State $X(1)\gets \sigma g$ // g - случайная величина, распределенная нормально с параметрами $N(0,1)$
	\For{j = 1,..., N}
		\For{i = 1,..., $2^{N-1}$}
		\State $X((2i - 1) 2^{N - j})$$\gets$ $X((i - 1)2^{N-j+1}) + X(i2^{N - j + 1}) + \frac{1}{2^{(j+1)/2}}$$\sigma$ g
		\EndFor
	\EndFor
\end{algorithmic}

\subsection{Фрактальное броуновское движение}

Фрактальное броуновское движение (ФБД) уже не является марковским процессом, а обладает некорой "памятью". Кроме того, вводя параметр $0 < H < 1$ можно получитьодномерное ФБД размерности $d = 2 - H$ и двумерное ФБД размерности $d = 3 - H$ .
Заметим, что классическое броуновское движение получается как частный случай при $H = 0.5$. Для апроксимации ФБД нет простого метода, вроде суммирования нормальных случайных величин, как в случае классического броуновского движения. Для апроксимации ФБД наиболее удобно использовать преобразования Фурье.

Рассмотрим случайный процесс (случайную величину) $X(t)$, заданную на отрезке $[0, T]$.

\textit{Случайный процесс}  $X(t)$ называется одномерным фрактальным броуновским движением на интервале $[0, T]$, если он обладает следущими свойствами:

\begin{itemize}
	\item $X(0) = 0$ почти наверное и $X(t)$ - почти наверне непрерывная функция на $[0, T]$
	\item  $X(t)$ - процесс с приращениями, распределенными нормально
\end{itemize}

Отметим следующие свойства фрактального броуновского движения:

\begin{itemize}
	\item $X(t)$ почти наверное нигде не дифференцируем 
	\item Фрактальная размерность графика $X(t)$ равна $2 - H$
	\item Процесс $x(t)$ не обладает свойством независимости приращений
	\item Приращение \textit{X(t)} обладает свойством статистического самоподобия: для любого $r$ > 0
	\begin{equation}
		X(t+ \bigtriangleup t) = \frac{1}{\sqrt{r}}(X(t+r\bigtriangleup t) - X(t))
	\end{equation}
	\item Стационарность приращений: дисперсия приращения зависит только от разности моментов времени
	\begin{equation} \label{1.6}
		D(X(t_2) - X(t_1)) = \sigma^2|t_2-t_1|^{2H}
	\end{equation}
	\item Математическое ожидание приращения равно
	\begin{equation}
		E(|X(t_2) - X(t_1)|) = \sqrt{\frac{2}{\pi}}\sigma|t_2-t_1|^H
	\end{equation}
\end{itemize}

\subsubsection{Метод Фурье-фильтрации для построения ФБД}

\newtheorem{theorem1}{Теорема}
\begin{theorem1}
	Если $X(t)$ - ФБД с параметром $H$, то его спектральная плотность 
	\begin{equation}
		S(f) \propto \frac{1}{f^{2H+1}}
	\end{equation}
\end{theorem1}

Идея метода состоит в следующем. Строится преобразование Фурье для искомого ФБД в частной области, задавая случайные фазы и подбирая амплитуды, удовлетворяющие свойству из Теоремы 1. Затем получаем ФБД во временной области с помощью обратного преобразования Фурье.

Будем моделировать дискретный аналог ФБД, то есть наша цель- получить величины $\left\{X_n\right\}_{n=0}^{N-1}$, апроксимирующиеФБД в точках $n$. Воспользуемся формулой дискретного преобразования Фурье

\begin{equation}
	\hat{X_n} = \sum_{k=0}^{N-1}X_ke^{-2\pi kn/N}
\end{equation}

и обратного дискретного преобразования Фурье

\begin{equation}
	X_n = \sum_{k=0}^{N-1}\hat{X_k}e^{2\pi kn/N}
\end{equation}

Далее будем рассматривать только четные значения $N$, а для применения метода \textit{быстрого дискретного преобразования Фурье} нужно, чтобы $N=2^M$, $M \in \mathbb{N}$. Метод быстрого дискретного преобразования Фурье  реализован во многих системах компьютерной алгебры. Он позволяет сократить вычисления в $\frac{2N}{\log_2N}$ раз.

Для того, чтобы получающиеся величины $X_n$ были вещественными мы наложим условие сопряженной симметрии:

\begin{equation}
	\hat{X}_0, \hat{X}_{N/2} \in \mathbb{R}, \hat{X}_n = \hat{X}_{N-n}, n = 1,...,N/2-1
\end{equation}

Фильтрация относится к той части моделирования, когда мы заставляем коэффициенты преобразования Фурье удовлетворять степенному закону из Теоремы 1:

\begin{equation}
	|\hat{X}_n|^2 \propto \frac{1}{n^{2H+1}}, n = 1,...,N/2
\end{equation}

Для этого возьмем

\begin{equation}
	\hat{X}_n = \frac{ge^{2\pi iu}}{n^{H+0.5}}
\end{equation}

где $g$ - независимые значения нормально распределенной случайной величины с параметрами $N(0,1)$, а $u$ - независимые значения равномерно распределенной на отрезке [0,1] случайной величины. Оставшиеся коэффициенты вечислим из сотношений 1.15.

Для вычисления искомой аппроксимации ФБД $\left\{X_n\right\}_{n=0}^{N-1}$ применим обратное дискретное преобразование Фурье к набору $\left\{\hat{X}_n\right\}_{n=0}^{N-1}$.

\subsubsection{Кривая ФБД методом Фурье-фильтрации}

Вход: $H \in (0,1)$, $N=2^M$, $M \in \mathbb{N}$ // $H$ - параметр ФБД, размерность графика равна $d = 2 - H$, $N$ - параметр, определяющий количество точек дискретизации ФБД.

Выход: массив значений $\left\{X_n\right\}_{n=0}^{N-1}$ // дискретная апроксимация ФБД в последовательные моменты времени n.

\begin{algorithmic}[1]
	\State $\hat{X}_0\gets g$
	\For{j = 1,..., N/2-1}
	\State $\hat{X}_j \gets \frac{ge^{2\pi iu}}{j^{H+0.5}}$
	\EndFor
	\State $\hat{X}_{N/2} \gets \frac{g\cos(2\pi iu)}{(N/2)^{H+0.5}}$ // Здесь $\cos$ — вещественная часть комплексной экспоненты $e$
	\For{j = N/2+1,..., N-1}
	\State $\hat{X}_j \gets \overline{\hat{X}_{N-j}}$
	\EndFor
	\State $X \gets convert(\hat{X})$ // Вектор $X = \left\{X_0,...,X_{N-1}\right\}$ получается обратным дискретным преобразованием Фурье из вектора $\hat{X} = \left\{\hat{X}_0,...,\hat{X}_{N-1}\right\}$.
\end{algorithmic}

Для построения апроксимации двумерного фрактального броуновского движения методом Фурье-фильтрации используются те же идеи, что и в одномерном случае. Вместо $\hat{X}_n$ используется $\hat{X}_{k,j}$, $k,j = \overline{0,N-1}$, условие Теоремы 1 примет вид:

\begin{equation}
	|\hat{X}_{k,j}|^2 \propto \frac{1}{(k^2+j^2)^{H+1}}, n,k= 1,...,N/2
\end{equation}

мы возьмем

\begin{equation}
	\hat{X}_{k,j} = \frac{ge^{2\pi iu}}{(k^2+j^2)^{H/2+0.5}}, n,k= 1,...,N/2
\end{equation}

Запишем обратное дискретное преобразование Фурье: для $m,n=\overline{0,N-1}$

\begin{gather}
	\begin{split}
		\hat{X}_{m,n} = \sum_{k=0}^{N-1}\sum_{j=0}^{N-1}\hat{X}_{k,j}e^{-2\pi i \frac{kn+jm}{N}} = \hat{X}_{0,0} + \sum_{k=1}^{N-1}\hat{X}_{k,0}e^{-2\pi i\frac{kn}{N}} + \sum_{j+1}^{N-1}\hat{X}_{0,j}e^{-2\pi i \frac{jm}{N}} + \\
		\sum_{k=1}^{N/2}\sum_{j=1}^{N/2}\hat{X}_{k,j}e^{-2\pi i \frac{kn+jm}{N}} + \sum_{k=\frac{N}{2}+1}^{N-1} \sum_{j=\frac{N}{2}+1}^{N-1}(...) + \sum_{k=1}^{N/2}\sum_{j=\frac{N}{2}+1}^{N-1}(...) + \sum_{k=\frac{N}{2}+1}^{N-1} \sum_{j=1}^{N/2}(...)
	\end{split}
\end{gather}

Из формулы (1.19) следует, что для вещественности всех величин $X_{m,n}$ достаточно выполнения следующих условий сопряженной симметрии:

\begin{align}
		\hat{X}_{N-k,N-j} &= \overline{\hat{X}_{k,j}} &k,j &= \overline{1,N/2} &\hat{X}_{N/2,N/2} & \in \mathbb{R}\\
		\hat{X}_{k,N-j} &= \overline{\hat{X}_{N-k,j}} &k,j &= \overline{1,N/2-1} &\hat{X}_{0,0} & \in \mathbb{R}\\
		\hat{X}_{0,N-j} &= \overline{\hat{X}_{0,j}} &j &= \overline{1,N/2} &\hat{X}_{0,N/2} & \in \mathbb{R}\\
		\hat{X}_{N-k,0} &= \overline{\hat{X}_{k,0}} &k &= \overline{1,N/2} &\hat{X}_{N/2,0} & \in \mathbb{R}
\end{align}

Условия (1.22)-(1.23) обеспечивают вещественность первых двух сумм, а условия (1.20)-(1.21) - оставшихся четырех сумм.

\subsubsection{Поверхность ФБД методом Фурье-фильтрации}

Вход: $H \in (0,1)$, $N=2^M$, $M \in \mathbb{N}$ // $H$ - параметр ФБД, размерность графика равна $d = 3 - H$, $N$ - параметр, определяющий количество точек ФБД по каждому из двух измерений.

Выход: массив значений $\left\{X_{n,k}\right\}_{n,k=0}^{N-1}$ // дискретная апроксимация ФБД на решетке узлов.

\begin{algorithmic}[1]
	\For{$j,k = 1,..., N/2$}
	\State $\hat{X}_{j,k} \gets \frac{ge^{2\pi iu}}{(j^2+k^2)^{H/2+0.5}}$
	\State$\hat{X}_{N-j,N-k} \gets \overline{\hat{X}_{j,k}}$
	\EndFor
	
	\For{$k = 1,..., N/2-1$}
	\State $\hat{X}_{0,k} \gets \frac{ge^{2\pi iu}}{(k^2)^{H/2+0.5}}$
	\State $\hat{X}_{k,0} \gets \frac{ge^{2\pi iu}}{(k^2)^{H/2+0.5}}$
	\State $\hat{X}_{0,N-k} \gets \overline{\hat{X}_{0,k}}$
	\State $\hat{X}_{N-k,0} \gets \overline{\hat{X}_{k,0}}$
	\EndFor
	
	\For{$j,k = 1,..., N/2-1$}
	\State $\hat{X}_{N-j,k} \gets \frac{ge^{2\pi iu}}{((N-j)^2+k^2)^{H/2+0.5}}$
	\State $\hat{X}_{j,N-k} \gets \overline{\hat{X}_{N-j,k}}$
	\EndFor
	
	\State $\hat{X}_{0,0} \gets 0$
	\State $\hat{X}_{N/2,0} \gets \frac{g\cos (2\pi u)}{((N/2)^2)^{H/2+0.5}}$
	\State $\hat{X}_{0,N/2} \gets \frac{g\cos (2\pi u)}{((N/2)^2)^{H/2+0.5}}$
	\State $\hat{X}_{N/2,N/2} \gets \frac{g\cos (2\pi u)}{(2(N/2)^2)^{H/2+0.5}}$
	
	\State $X \gets convert(\hat{X})$ // Обратное дискретное преобразование Фурье матрицы $\hat{X} = \left\{X_{j,k}\right\}_{j,k=0}^{N-1}$.
\end{algorithmic}

\subsection*{Вывод}


\section{Формализация модели}
Модель броуновского движения частиц будет задаваться такими характеристиками, как:
\begin{itemize} 
    \item размер частиц -- число типа $int$.
\end{itemize}

Также частью на сцене будет изображено помещение. 


\section{Выбор метода рендера изображения}

Рендеринг или отрисовка -- термин в компьютерной графике, обозначающий процесс получения изображения по модели с помощью компьютерной программы.

Основным методом для генерации водопада была выбрана система частиц, которая показывает наилучшие результаты при большом количестве объектов. Программа должна работать быстро, чтобы был виден результат, похожий на поток воды. Для рендера системы частиц не подходит стандартная графическая библиотека, поскольку она не справится с нагрузкой, которая будет на нее возложена. Следовательно, необходимо выбрать API, которое позволит более гибко управлять данными, а также использовать графический ускоритель для рендера изображения. Основными API являются DirectX, Vulkan и OpenGL.

\subsection{DirectX}

\textbf{DirectX} -- это последняя версия собственного API компьютерной графики от Microsoft, используемого для платформ Windows и Xbox. Он нацелен на создание менее сложного драйвера и API, более близкого к архитектуре современных графических процессоров. DirectX фокусируется на рендеринге в реальном времени, поэтому он предназначен для разработчиков игр и систем автоматизированного проектирования (CAD). Поскольку это отраслевой стандарт API компьютерной графики, можно ожидать, что почти все совместимые аппаратные средства будут иметь его надежную поддержку, и он станет стандартом для коммерческих проектов.

Этапы рендеринга растровой графики с помощью DirectX очень похожи на этапы других современных графических API. 

\begin{enumerate}
    \item \textit{Инициализация API} — создаются:

    \begin{itemize}
        \item фабрика -- точка входа в DirectX API;
        \item адаптер -- предоставляет информацию о физических характеристиках данного устройства DirectX;
        \item устройство -- основная точка входа в DirectX API, предоставляющая доступ к внутренним частям API. Это ключ к важным структурам данных, таким как конвейеры, шейдеры, состояние рендеринга;
        \item очередь команд -- позволяет отправлять группы вызовов отрисовки, известных как списки команд, для выполнения по порядку, что позволяет графическому процессору оставаться занятым и оптимизировать скорость его работы;
        \item распределитель команд -- используется для создания списка команд, то есть структуры данных, в которой выполняются вызовы отрисовки к GPU.
    \end{itemize}
    \item \textit{Инициализация ресурсов} — создаются:
    \begin{itemize}
        \item буфер вершин -- хранит информацию о каждой вершине, доступную в виде атрибутов в вершинном шейдере;
        \item индексный буфер -- содержит индивидуальные индексы каждых треугольника/линии/точки, которые нужно нарисовать;
        \item однородный буфер -- описывает данные, которые будут посылаться во время отрисовки к стадиям шейдеров (например, цвет).
    \end{itemize}
    \item \textit{Визуализация} — обновление однородных данных, добавление команд в очередь и ожидание следующего кадра.
\end{enumerate}


\textbf{Преимущества:} 
\begin{itemize}
    \item высокое качество изображения;
    \item быстрый рендер изборажения.
\end{itemize}

\textbf{Недостатки:} 
\begin{itemize}
    \item новые версии только для самого современного оборудования (не поддерживается старыми видеокартами);
    \item используется только на Windows.
\end{itemize}


\subsection{OpenGL}

OpenGL -- в большинстве случаев рассматривается как API, предоставляющий большой набор функций, которые можно использовать для управления графикой и изображениями. OpenGL является спецификацией, разработанной и поддерживаемой Khronos Group.

Спецификация OpenGL определяет, каким должен быть результат/вывод каждой функции, и как она должна выполняться. А вот реализация этой спецификации уже зависит от конкретных разработчиков.

Если не ограничиваться аппаратурой, а рассмотреть поддержку графической обработки для современных систем в целом, то видно, что она базируется на понятии конвейера: графические данные проходят последовательно несколько этапов обработки -- выходные данные одного этапа сразу передаются на вход следующего. Абстрагируясь от связанных с конкретными реализациями деталей, можно рассмотреть универсальный графический конвейер и выделить в нем 5 этапов.

\begin{enumerate}
    \item Этап генерации (G) -- создание и модификация прикладных структур данных.
    \item Этап обхода (T) прикладных структур данных и порождение соответствующих графических данных.
    \item Этап преобразования (X), на котором графические данные из системы координат объекта преобразуются в систему координат наблюдателя, выполняется расчет освещенности, отсечение преобразованных данных, а затем проецирование результата в пространство окна.
    \item На этапе растеризации (R) создаются и записываются в буфер кадра дискретные образы примитивов: точки, отрезки и полигоны. Буфер кадра -- это банк памяти, предназначенный для хранения массива пикселей изображения. На этом этапе для всех вершин геометрических объектов вычисляется закраска, производится наложение определенных участков текстуры, а также выполняются пиксельные операции, такие, например, как сравнение по глубине.
    \item На этапе вывода (D) происходит сканирование буфера кадра и вывод изображения на экран дисплея.
\end{enumerate}


\textbf{Преимущества:} 
\begin{itemize}
    \item высокая производительность работы;
    \item гибкая структура, которая позволяет изменять параметры выводимых объектов;
    \item кроссплатформенность (используется на Linux, MacOS, Windows);
    \item библиотеки для работы с API на различных языках программирования.
\end{itemize}

\textbf{Недостатки:} 
\begin{itemize}
    \item сложная работа с новыми возможностями GPU;
    \item не имеет возможности для работы с мышью и клавиатурой (нужно отдельное API).
\end{itemize}


\subsection{Vulkan}

Vulkan — кроссплатформенный API для 2D- и 3D-графики, представленный Khronos Group.

Vulkan API изначально был известен как <<новое поколение OpenGL>> или просто <<glNext>>, но после анонса компания отказалась от этих названий в пользу названия Vulkan. Как и OpenGL, Vulkan позволяет с высокой производительностью отображать в реальном времени различные приложения с 3D-графикой, такие как игры или интерактивные книги на всех платформах, а также обеспечивает более высокую производительность и меньшую нагрузку на процессор.

Перед получением изображения на экран, Vulkan выполняет ряд следующих действий.

\begin{enumerate}
    \item \textbf{Подготовка}. Нужно сообщить Vulkan, какие буферы будут использоваться во время рендеринга. Необходимо указать, сколько будет буферов цвета, буферов глубины. Также нужно указать, как должно обрабатываться содержимое буферов во время рендеринга. Вся эта информация обернута в объект прохода рендера.
    \item \textbf{Настройка буферов}. Настраиваются буферы глубины и цвета, в которые загружаются данные. При конфигурации используются два основных метода, для каждого буфера: \textit{loadOp} и \textit{storeOp}. Для \textit{loadOp} возможны следующие значения:
    \begin{itemize}
        \item \textit{VK\_ATTACHMENT\_LOAD\_OP\_LOAD} -- буфер будет содержать те данные, которые были помещены в него до этого прохода (например, во время предыдущего прохода);
        \item \textit{VK\_ATTACHMENT\_LOAD\_OP\_CLEAR} -- буфер очищается в начале прохода рендера;
        \item \textit{VK\_ATTACHMENT\_LOAD\_OP\_DONT\_CARE} -- содержимое буфера не определено.
    \end{itemize}

    Для \textit{storeOp} возможны два значения:
    \begin{itemize}
        \item \textit{VK\_ATTACHMENT\_STORE\_OP\_STORE} -- содержимое буфера сохраняется в память для дальнейшего использования;
        \item \textit{VK\_ATTACHMENT\_STORE\_OP\_DONT\_CARE} -- после рендеринга буфер больше не используется, и его содержимое не имеет значения.
    \end{itemize}
    \item \textbf{Подпроходы}. Один проход рендера может состоять из множества подпроходов. Подпроходы -- это последовательные операции рендеринга, зависящие от содержимого фреймбуферов в предыдущих проходах. К ним относятся, например, эффекты постобработки, применяемые друг за другом. Если объединить их в один проход рендера, Vulkan сможет перегруппировать операции для лучшего сохранения пропускной способности памяти и большей производительности. Каждый подпроход ссылается на один или несколько буферов.
    \item \textbf{Проход рендера}. Вывод изображения на экран дисплея.
\end{enumerate}


\textbf{Преимущества:} 
\begin{itemize}
    \item высокая производительность работы;
    \item открытый код;
    \item кроссплатформенность (используется на Linux, MacOS, Windows).
\end{itemize}

\textbf{Недостатки:} 
\begin{itemize}
    \item работа на глубоком уровнем GPU;
    \item не имеет библиотек, позволяющих полноценно использовать Vulkan на другом языке.
\end{itemize}


\subsection*{Вывод}

Проанализировав различные API для рендера изображения на экран, был выбран OpenGL. Он отличается кроссплатформенностью, что дает ему выигрыш над DirectX, потому что DirectX используется исключительно для операционных систем Windows. Также Vulkan не имеет библиотек для языка программирования Python, которые предоставляли бы весь функционал API Vulkan. Следовательно, OpenGL выбран в качестве приоритетного метода для рендера изображения системы частиц водопада. 


% \section{Выбор алгоритма удаления невидимых ребер и поверхностей}
% Для начала выделим несколько свойств, которыми должен обладать выбранный алгоритм, чтобы обеспечить оптимальную работу и реалистичное изображение.

% Свойства:
% \begin{itemize} 
%     \item алгоритм может работать как в объектном пространстве, так и в пространстве изображений;
%     \item алгоритм должен быть достаточно быстрым и использовать мало памяти.
% \end{itemize}


% \subsection{Алгоритм, использующий Z-буфер}
% \textit{Суть данного алгоритма} -- это использование двух буферов: буфера кадра, в котором хранятся атрибуты каждого пикселя, и Z-буфера, в котором хранятся информация о координате Z для каждого пикселя.

% Изначально в Z-буфере находятся минимальные значения Z, а в буфере кадра -- информация о пикселях, которые описывают фон. Глубина каждого нового пикселя при подсчете сравнивается со значением, которое уже есть в Z-буфере. В случае, если новый пиксель расположен ближе к наблюдателю, чем предыдущий, то информация о нем заносится в буфер кадра и происходит редактирование Z-буфера.

% \textit{Положительной стороной} данного алгоритма является простота реализация, экономия времени, так как нет сортировки.

% \textit{Недостатком} -- большой объем требуемой памяти, а также сложная реализация эффектов прозрачности.


% \subsection{Алгоритм обратной трассировки лучей}
% \textit{Суть данного алгоритма} состоит в том, что наблюдатель видит объект с помощью испускаемого света, который согласно законам оптики доходит до наблюдателя некоторым путем. Алгоритм называется “обратной трассировкой” из-за того, что эффективнее выходит отслеживать лучи, которые идут от наблюдателя к объекту.

% \textit{Положительным моментом} в этом алгоритме является возможность использования в параллельных вычислительных системах.

% \textit{Недостатком} же является то, что требуется большое количество необходимых вычислений.


% \subsection{Алгоритм Робертса}
% Данный алгоритм решает задачу удаления невидимых ребер и граней только с выпуклыми телами, работает только в объектном пространстве.

% У алгоритма три этапа выполнения:

% \begin{itemize} 
%     \item этап 0 -- подготовка данных; 
%     \item этап 1 -- удаление ребер, экранируемых самим телом; 
%     \item этап 2 -- удаление невидимых ребер, экранируемых другими телами сцены.
% \end{itemize}  

% \textit{Положительным моментом} в этом алгоритме является высокая точность вычислений. 

% \textit{Недостатком} же является то, что все тела должны быть выпуклыми.

% \subsection{Алгоритм художника}
% Данный алгоритм работает аналогично тому, как художник рисует картину -- то есть сначала рисуются дальние объекты, а затем более близкие. Наиболее распространенная реализация алгоритма -- сортировка по глубине, которая заключается в том, что произвольное множество граней сортируется по ближнему расстоянию от наблюдателя, а затем отсортированные грани выводятся на экран в порядке от самой дальней до самой ближней. Данный метод работает лучше для построения сцен, в которых отсутствуют пересекающиеся грани. 

% \textit{Положительным моментом} является то, что данный алгоритм требует памяти меньше, чем, например, алгоритм Z-буфера.

% \textit{Недостатком} же является то, что у него недостаточно высока реалистичность изображения.

% \subsection*{Вывод}
% Для удаления невидимых линий выбран алгоритм Z-буфера. Данный алгоритм довольно прост в реализации, работает довольно быстро из-за отсутствия сортировок, а также позволяет добиться хорошей реалистичности, что очень важно при моделировании таких  явлений природы, как водопад.
 

\section{Существующие программные обеспечения}
\textit{Blender} -- бесплатный, кроссплатформенный набор инструментов для работы с 3D с открытым кодом. Он обладает широким функционалом: подходит для моделирования, симуляции, рендеринга, монтажа, записи видео и создания игр.

Благодаря огромному количеству аддонов, которые создают сами пользователи, можно смоделировать практически все, что угодно. Это относится и к водопаду, который можно пустить по любой поверхности, при этом это будет выглядеть максимально реалистично.

На фотографиях ниже представлен пример такого водопада.
\imgHeight{60mm}{waterfall_example1.jpg}{Пример реализации водопада в программе Blender ч.1}
\imgHeight{60mm}{waterfall_example2.jpg}{Пример реализации водопада в программе Blender ч.2}
\imgHeight{60mm}{waterfall_example3.jpg}{Пример реализации водопада в программе Blender ч.3}
\imgHeight{60mm}{waterfall_example4.jpg}{Пример реализации водопада в программе Blender ч.4}
\clearpage

\section*{Вывод}

В данном разделе были формально описаны все методы по визуализации текучей воды, с помощью которых можно получить реализацию водопада, а также методы рендера изображения. В качестве алгоритма визуализации водопада предпочтение отдается методу, который реализует подход, основанный на системе частиц. Также OpenGL был выбран в качестве метода рендера изображения.

% В данном разделе были формально описаны все методы по визуализации текучей воды, с помощью которых можно получить реализиацию водопада, а также методы удаления невидимых линий и поверхностей и закрашивания областей. В качестве алгоритма визуализации водопада предпочтение отдается методу, который реализует подход, основанный на системе частиц. В качестве алгоритма удаления невидимых линий и областей -- z-буфер.
